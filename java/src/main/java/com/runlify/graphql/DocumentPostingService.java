package com.runlify.graphql;

import com.runlify.metadata.EntityMetadata;
import com.runlify.metadata.ProjectMetadata;
import com.runlify.schema.SchemaGenerator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

import java.util.*;

/**
 * Handles the document â†’ registry posting lifecycle:
 * <ul>
 *   <li>post (on create): compute registry entries and INSERT them</li>
 *   <li>rePost (on update): DELETE old entries, INSERT new ones</li>
 *   <li>unPost (on delete): DELETE entries for the document</li>
 * </ul>
 */
@Service
public class DocumentPostingService {

    private static final Logger log = LoggerFactory.getLogger(DocumentPostingService.class);

    private final JdbcTemplate jdbc;
    private final ProjectMetadata metadata;

    public DocumentPostingService(JdbcTemplate jdbc,
                                  com.runlify.metadata.MetadataLoader metadataLoader) {
        this.jdbc = jdbc;
        this.metadata = metadataLoader.getMetadata();
    }

    /**
     * Post a document: create registry entries for all linked registries.
     */
    public void post(EntityMetadata docEntity, Map<String, Object> docData) {
        for (var registryName : docEntity.registries()) {
            var registry = findRegistry(registryName);
            if (registry == null) continue;

            var entries = computeEntries(docEntity, docData, registry);
            for (var entry : entries) {
                insertEntry(registry, entry);
            }
            log.debug("Posted {} entries to {} for document {}",
                entries.size(), registryName, docData.get("id"));
        }
    }

    /**
     * Re-post a document: delete old entries, insert new ones.
     */
    public void rePost(EntityMetadata docEntity, Map<String, Object> docData) {
        unPost(docEntity, docData.get("id"));
        post(docEntity, docData);
    }

    /**
     * Un-post a document: delete all registry entries for this document.
     */
    public void unPost(EntityMetadata docEntity, Object docId) {
        var singular = SchemaGenerator.pascalSingular(docEntity.name());
        // registrarTypeId uses the singular lowercase form (e.g., "invoice")
        var registrarType = Character.toLowerCase(singular.charAt(0)) + singular.substring(1);

        for (var registryName : docEntity.registries()) {
            var registry = findRegistry(registryName);
            if (registry == null) continue;

            var table = SchemaGenerator.tableName(registry);
            var deleted = jdbc.update(
                "DELETE FROM \"%s\" WHERE \"registrarTypeId\" = ? AND \"registrarId\" = ?"
                    .formatted(table),
                registrarType, docId);
            log.debug("Un-posted {} entries from {} for document {}",
                deleted, registryName, docId);
        }
    }

    /**
     * Compute registry entries for a document.
     * Default: one entry per document with matching dimension/resource values.
     */
    private List<Map<String, Object>> computeEntries(
        EntityMetadata docEntity, Map<String, Object> docData, EntityMetadata registry
    ) {
        var singular = SchemaGenerator.pascalSingular(docEntity.name());
        var registrarType = Character.toLowerCase(singular.charAt(0)) + singular.substring(1);

        var entry = new LinkedHashMap<String, Object>();

        // Auto-generate id for the registry entry
        var idField = registry.idField();
        if (idField.isAutoGenerated() && "cuid()".equals(idField.defaultDbValue())) {
            entry.put("id", CrudDataFetcherFactory.generateCuid());
        }

        // Standard registrar fields
        entry.put("registrarTypeId", registrarType);
        entry.put("registrarId", docData.get("id"));
        entry.put("row", 1);

        // Copy matching dimensions (skip registrar-related ones)
        for (var dim : registry.dimensions()) {
            var name = dim.name();
            if ("registrarTypeId".equals(name) || "registrarId".equals(name) || "row".equals(name)) {
                continue;
            }
            if (docData.containsKey(name)) {
                entry.put(name, docData.get(name));
            }
        }

        // Copy matching resources
        for (var res : registry.resources()) {
            if (docData.containsKey(res.name())) {
                entry.put(res.name(), docData.get(res.name()));
            }
        }

        return List.of(entry);
    }

    private void insertEntry(EntityMetadata registry, Map<String, Object> entry) {
        var table = SchemaGenerator.tableName(registry);
        var columns = entry.keySet().stream()
            .map(c -> "\"%s\"".formatted(c))
            .collect(java.util.stream.Collectors.joining(", "));
        var placeholders = entry.keySet().stream()
            .map(c -> "?")
            .collect(java.util.stream.Collectors.joining(", "));
        var sql = "INSERT INTO \"%s\" (%s) VALUES (%s)".formatted(table, columns, placeholders);
        jdbc.update(sql, entry.values().toArray());
    }

    private EntityMetadata findRegistry(String name) {
        return metadata.allEntities().stream()
            .filter(e -> e.name().equals(name) && e.isRegistry())
            .findFirst()
            .orElse(null);
    }
}
