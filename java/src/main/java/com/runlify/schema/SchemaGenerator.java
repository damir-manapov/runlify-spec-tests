package com.runlify.schema;

import com.runlify.metadata.EntityMetadata;
import com.runlify.metadata.FieldMetadata;
import com.runlify.metadata.ProjectMetadata;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Generates PostgreSQL DDL (CREATE TABLE) from project metadata.
 * Table names follow runlify convention: PascalCase singular of entity name.
 */
@Component
public class SchemaGenerator {

    private static final Logger log = LoggerFactory.getLogger(SchemaGenerator.class);

    /**
     * Generate DDL for all entities in the project.
     * Returns a list of SQL statements (DROP + CREATE for each entity).
     */
    public List<String> generateDdl(ProjectMetadata metadata) {
        var statements = new ArrayList<String>();
        for (var entity : metadata.allEntities()) {
            statements.add(generateDropTable(entity));
            statements.add(generateCreateTable(entity));
        }
        return statements;
    }

    /**
     * Generate a single CREATE TABLE statement for an entity.
     */
    public String generateCreateTable(EntityMetadata entity) {
        var tableName = tableName(entity);
        var columns = new ArrayList<String>();

        for (var field : entity.fields()) {
            columns.add(columnDef(field));
        }

        var sb = new StringBuilder();
        sb.append("CREATE TABLE \"%s\" (\n".formatted(tableName));
        sb.append(String.join(",\n", columns.stream()
            .map(c -> "  " + c)
            .toList()));

        // Unique constraints (beyond the primary key)
        for (var uc : entity.uniqueConstraints()) {
            var cols = uc.stream()
                .map(c -> "\"%s\"".formatted(c))
                .collect(Collectors.joining(", "));
            sb.append(",\n  UNIQUE (%s)".formatted(cols));
        }

        sb.append("\n)");

        log.debug("Generated DDL for {}: {} columns, {} unique constraints",
            tableName, entity.fields().size(), entity.uniqueConstraints().size());

        return sb.toString();
    }

    public String generateDropTable(EntityMetadata entity) {
        return "DROP TABLE IF EXISTS \"%s\" CASCADE".formatted(tableName(entity));
    }

    /**
     * Convert entity name to table name: PascalCase singular.
     * "items" → "Item", "invoiceTotals" → "InvoiceTotal", "prices" → "Price"
     */
    public static String tableName(EntityMetadata entity) {
        return pascalSingular(entity.name());
    }

    /**
     * Generate a column definition for a field.
     */
    private String columnDef(FieldMetadata field) {
        var sb = new StringBuilder();
        sb.append("\"%s\" ".formatted(field.name()));

        // Type + auto-increment handling
        if (field.isId() && field.isAutoGenerated() && "autoincrement()".equals(field.defaultDbValue())) {
            // Use SERIAL/BIGSERIAL for auto-increment IDs
            sb.append("bigint".equals(field.type()) ? "BIGSERIAL" : "SERIAL");
        } else {
            sb.append(field.sqlType());
        }

        // PRIMARY KEY for id fields
        if (field.isId()) {
            sb.append(" PRIMARY KEY");
        }

        // NOT NULL for required fields (unless auto-generated id — SERIAL is always NOT NULL)
        if (field.isRequired() && !field.isId()) {
            sb.append(" NOT NULL");
        }

        // Default values
        if (field.isId() && field.isAutoGenerated() && "cuid()".equals(field.defaultDbValue())) {
            // No DB-level default for cuid — we generate it in Java
        } else if (field.defaultBackendValueExpression() != null
            && !field.defaultBackendValueExpression().isEmpty()) {
            var expr = field.defaultBackendValueExpression();
            // Convert expression literals: "''" → ''
            sb.append(" DEFAULT %s".formatted(sqlDefault(expr)));
        }

        return sb.toString();
    }

    /**
     * Convert a backend value expression to a SQL DEFAULT value.
     * "''" → DEFAULT ''
     * "1"  → DEFAULT 1
     */
    private String sqlDefault(String expr) {
        // Already quoted string like "''"
        if (expr.startsWith("'") && expr.endsWith("'")) {
            return expr;
        }
        // Numeric or boolean literal
        return expr;
    }

    /**
     * Singularize + PascalCase: "items" → "Item", "invoiceTotals" → "InvoiceTotal"
     */
    public static String pascalSingular(String name) {
        // Simple singularize: strip trailing 's' (handles most cases)
        var singular = singularize(name);
        // Ensure first letter is uppercase (the rest is already camelCase from metadata)
        return Character.toUpperCase(singular.charAt(0)) + singular.substring(1);
    }

    /**
     * Naive singularize — handles the common patterns from runlify metadata:
     * "items" → "item", "categories" → "category", "prices" → "price",
     * "invoices" → "invoice", "invoiceTotals" → "invoiceTotal"
     */
    static String singularize(String name) {
        if (name.endsWith("ies")) {
            // categories → category
            return name.substring(0, name.length() - 3) + "y";
        }
        if (name.endsWith("ses") || name.endsWith("zes") || name.endsWith("xes")) {
            // addresses → address (but not "prices" which ends in "ces")
            return name.substring(0, name.length() - 2);
        }
        if (name.endsWith("s") && !name.endsWith("ss")) {
            // items → item, prices → price, invoiceTotals → invoiceTotal
            return name.substring(0, name.length() - 1);
        }
        return name;
    }
}
