package com.runlify.schema;

import com.runlify.metadata.EntityMetadata;
import com.runlify.metadata.EntityNames;
import com.runlify.metadata.FieldMetadata;
import com.runlify.metadata.ProjectMetadata;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Generates PostgreSQL DDL (CREATE TABLE) from project metadata.
 * Table names follow runlify convention: PascalCase singular of entity name.
 */
@Component
public class SchemaGenerator {

    private static final Logger log = LoggerFactory.getLogger(SchemaGenerator.class);

    /**
     * Generate DDL for all entities in the project.
     * Returns a list of SQL statements (DROP + CREATE for each entity).
     */
    public List<String> generateDdl(ProjectMetadata metadata) {
        var statements = new ArrayList<String>();
        for (var entity : metadata.allEntities()) {
            statements.add(generateDropTable(entity));
            statements.add(generateCreateTable(entity));
        }
        return statements;
    }

    /**
     * Generate a single CREATE TABLE statement for an entity.
     */
    public String generateCreateTable(EntityMetadata entity) {
        var tableName = EntityNames.tableName(entity);
        var columns = new ArrayList<String>();

        for (var field : entity.fields()) {
            columns.add(columnDef(field));
        }

        var sb = new StringBuilder();
        sb.append("CREATE TABLE \"%s\" (\n".formatted(tableName));
        sb.append(String.join(",\n", columns.stream()
            .map(c -> "  " + c)
            .toList()));

        // Unique constraints (beyond the primary key)
        for (var uc : entity.uniqueConstraints()) {
            var cols = uc.stream()
                .map(c -> "\"%s\"".formatted(c))
                .collect(Collectors.joining(", "));
            sb.append(",\n  UNIQUE (%s)".formatted(cols));
        }

        sb.append("\n)");

        log.debug("Generated DDL for {}: {} columns, {} unique constraints",
            tableName, entity.fields().size(), entity.uniqueConstraints().size());

        return sb.toString();
    }

    public String generateDropTable(EntityMetadata entity) {
        return "DROP TABLE IF EXISTS \"%s\" CASCADE".formatted(EntityNames.tableName(entity));
    }

    /**
     * Generate a column definition for a field.
     */
    private String columnDef(FieldMetadata field) {
        var sb = new StringBuilder();
        sb.append("\"%s\" ".formatted(field.name()));

        // Type + auto-increment handling
        if (field.isId() && field.isAutoGenerated() && "autoincrement()".equals(field.defaultDbValue())) {
            // Use SERIAL/BIGSERIAL for auto-increment IDs
            sb.append("bigint".equals(field.type()) ? "BIGSERIAL" : "SERIAL");
        } else {
            sb.append(field.sqlType());
        }

        // PRIMARY KEY for id fields
        if (field.isId()) {
            sb.append(" PRIMARY KEY");
        }

        // NOT NULL for required fields (unless auto-generated id — SERIAL is always NOT NULL)
        if (field.isRequired() && !field.isId()) {
            sb.append(" NOT NULL");
        }

        // Default values
        if (field.isId() && field.isAutoGenerated() && "cuid()".equals(field.defaultDbValue())) {
            // No DB-level default for cuid — we generate it in Java
        } else if (field.defaultBackendValueExpression() != null
            && !field.defaultBackendValueExpression().isEmpty()) {
            var expr = field.defaultBackendValueExpression();
            // Convert expression literals: "''" → ''
            sb.append(" DEFAULT %s".formatted(sqlDefault(expr)));
        }

        return sb.toString();
    }

    /**
     * Convert a backend value expression to a SQL DEFAULT value.
     * "''" → DEFAULT ''
     * "1"  → DEFAULT 1
     */
    private String sqlDefault(String expr) {
        // Already quoted string like "''"
        if (expr.startsWith("'") && expr.endsWith("'")) {
            return expr;
        }
        // Numeric or boolean literal
        return expr;
    }
}
