# Runlify Java Implementation — Plan

A standalone Spring Boot backend that reads the same `metadata.json` format,
generates a PostgreSQL schema, runs migrations, and serves an identical GraphQL interface.

---

## Phase 1 — Foundation

### 1. Project skeleton & Gradle setup
- `settings.gradle.kts`, Gradle wrapper, `application.properties`, `RunlifyJavaApplication` main class
- Configure PostgreSQL datasource, GraphQL endpoint, server port from env vars
- `.gitignore` for java build artifacts

### 2. Metadata model POJOs
- Jackson records matching `metadata.json`:
  - `ProjectMetadata` (name, prefix, catalogs[], documents[], infoRegistries[], sumRegistries[])
  - `EntityMetadata` (name, type, fields[], dimensions[], resources[], registries[], registrarDepended, uniqueConstraints[], period, searchEnabled, defaultSort)
  - `FieldMetadata` (name, type, category, required, requiredOnInput, updatable, updatableByUser, hidden, searchable, array, filters[], autoGenerated, defaultDbValue, linkEntity, numberType, stringType, defaultBackendValueExpression)
- `MetadataLoader` service — reads metadata.json from configurable path

### 3. DDL generator
- `SchemaGenerator`: EntityMetadata → `CREATE TABLE` DDL
- Type mapping: string→TEXT, int→INTEGER, float→DOUBLE PRECISION, bool→BOOLEAN, datetime→TIMESTAMPTZ, date→DATE, bigint→BIGINT
- Handles: `@id` with cuid()/autoincrement(), unique constraints, NOT NULL, default values, hidden `search` column

### 4. Migration runner
- `MigrationService` runs on startup — drops & recreates tables via `JdbcTemplate`
- `?schema=` support on DATABASE_URL for parallel test isolation
- Order: catalogs → documents → registries

---

## Phase 2 — GraphQL

### 5. Dynamic GraphQL schema builder
- Programmatic SDL from metadata at startup
- Per entity: type + filterInput + queries + mutations
  - `Entity(id)`, `allEntities(sortField, sortOrder, page, perPage, filter)`, `_allEntitiesMeta`
  - `createEntity(...)`, `updateEntity(...)`, `removeEntity(id)`
- For periodic info registries: `sliceOfTheLastEntity(...)`, `sliceOfTheFirstEntity(...)`

### 6. Generic CRUD data fetchers
- `GenericDataFetcherFactory` — DataFetcher per operation:
  - CREATE → `INSERT INTO ... RETURNING *`
  - FIND_ONE → `SELECT * WHERE id = ?`
  - FIND_ALL → SELECT with filter/sort/pagination
  - UPDATE → `UPDATE ... SET ... WHERE id = ?`
  - REMOVE → `DELETE WHERE id = ?`
  - COUNT → `SELECT COUNT(*)`
- Filter support: `q` (ILIKE on search column), `ids`, `_gte`, `_lte`, `_in`, `_not_in`, `_defined`
- Auto-populate `search` field from `searchable` fields on create/update

---

## Phase 3 — Advanced features

### 7. Document posting lifecycle
- `DocumentPostingService`:
  - Create → `afterPostHandle` computes registry entries & INSERTs
  - Update → delete old entries + re-insert (rePost)
  - Delete → delete entries (unPost)
- Uses `registrarTypeId` / `registrarId` / `row` dimensions

### 8. Info registry slice methods
- `SliceService`:
  - `sliceOfTheLast(date, ...dims)` → `SELECT ... WHERE date <= ? ORDER BY date DESC LIMIT 1`
  - `sliceOfTheFirst(date, ...dims)` → `... ORDER BY date ASC LIMIT 1`

---

## Phase 4 — Integration

### 9. Application wiring & config
- Spring Boot: MetadataLoader → SchemaGenerator → MigrationService → DynamicGraphQlSource
- Config: `METADATA_PATH`, `DATABASE_URL`, `SERVER_PORT`
- GraphQL endpoint at `/graphql`

### 10. Smoke test
- Start Java app with `with-auto-id` fixture, curl `/graphql`, verify create + findAll

### 11. Integration test harness
- `prepare-java-backend.ts` — builds JAR, starts Java process, returns `StartedServer`
- `java-api.spec.ts` — same CRUD/filter/sort assertions as existing TypeScript tests
- Proves API-level compatibility with runlify-generated backends

### 12. Git commit & push

---

## Key design decisions

- **Dynamic schema** — no code generation step; one generic service handles all entity types, parameterized by metadata
- **Same DB** — PostgreSQL, same `?schema=` isolation pattern for test parallelism
- **Same wire format** — identical GraphQL operation names, argument shapes, response structures
- **No Hibernate/JPA** — raw JDBC via `JdbcTemplate` since the schema is fully dynamic
- **CUID generation** — Java-side library to match `cuid()` defaults
