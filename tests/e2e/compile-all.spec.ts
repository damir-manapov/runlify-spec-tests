import fs from 'node:fs'
import path from 'node:path'
import { afterAll, beforeAll, describe, expect, it } from 'vitest'
import {
  type PreparedBackend,
  prepareBackend,
  readSchema,
  readTypeDefs,
  runOrFail,
  teardownBackend,
} from './prepare-backend.js'

// ---------------------------------------------------------------------------
// Fixture configuration table — each row defines a fixture and its assertions
// ---------------------------------------------------------------------------

interface PrismaCheck {
  model: string
  idType: 'Int' | 'BigInt' | 'String'
  hasAutoincrement?: boolean
  hasCuid?: boolean
  extraFields?: Array<{ pattern: RegExp }>
  hasRelation?: { field: string; type: string; optional?: boolean }
}

interface TypeDefsCheck {
  entity: string
  service: string // folder name under graph/services/
  gqlIdType: 'Int!' | 'BigInt!' | 'ID!'
  requiredFields?: string[] // e.g. ['name: String!', 'quantity: Int!']
  optionalFields?: string[] // e.g. ['description: String']
  createMutationIdBehaviour: 'required' | 'absent'
  createMutationIdPattern?: RegExp // when behaviour is 'required'
  filters?: string[] // e.g. ['quantity_lte: Int']
}

interface ServiceConfigCheck {
  serviceName: string // folder under services/, e.g. 'EntriesService'
  autogeneratedStringId: boolean
  idType?: string // 'string' | 'bigint' | 'int'
}

interface EntityTsCheck {
  names: string[] // entity names that should appear in Entity.ts
}

interface FixtureSpec {
  fixture: string
  label: string
  prisma: PrismaCheck | PrismaCheck[]
  typeDefs: TypeDefsCheck | TypeDefsCheck[]
  serviceConfig?: ServiceConfigCheck
  entityTs?: EntityTsCheck
}

const fixtures: FixtureSpec[] = [
  // ---- int + autoincrement ----
  {
    fixture: 'with-auto-id',
    label: 'int id (autoincrement)',
    prisma: {
      model: 'Item',
      idType: 'Int',
      hasAutoincrement: true,
      extraFields: [
        { pattern: /name\s+String/ },
        { pattern: /quantity\s+Int/ },
        { pattern: /active\s+Boolean/ },
        { pattern: /description\s+String\?/ },
        { pattern: /createdAt\s+DateTime\?/ },
      ],
    },
    typeDefs: {
      entity: 'Item',
      service: 'items',
      gqlIdType: 'Int!',
      requiredFields: ['name: String!', 'quantity: Int!', 'active: Boolean!'],
      optionalFields: ['description: String', 'createdAt: DateTime'],
      createMutationIdBehaviour: 'absent',
      filters: [
        'quantity_lte: Int',
        'quantity_gte: Int',
        'createdAt_lte: DateTime',
        'createdAt_gte: DateTime',
      ],
    },
  },

  // ---- int + manual ----
  {
    fixture: 'with-manual-int-id',
    label: 'int id (user-provided)',
    prisma: {
      model: 'Entry',
      idType: 'Int',
      hasAutoincrement: false,
      extraFields: [{ pattern: /label\s+String/ }],
    },
    typeDefs: {
      entity: 'Entry',
      service: 'entries',
      gqlIdType: 'Int!',
      requiredFields: ['label: String!'],
      createMutationIdBehaviour: 'required',
      createMutationIdPattern: /\bid\s*:\s*Int!/,
    },
    serviceConfig: { serviceName: 'EntriesService', autogeneratedStringId: false },
  },

  // ---- bigint + autoincrement ----
  {
    fixture: 'with-bigint-id',
    label: 'bigint id (autoincrement)',
    prisma: {
      model: 'Counter',
      idType: 'BigInt',
      hasAutoincrement: true,
      extraFields: [{ pattern: /label\s+String/ }],
    },
    typeDefs: {
      entity: 'Counter',
      service: 'counters',
      gqlIdType: 'BigInt!',
      requiredFields: ['label: String!'],
      createMutationIdBehaviour: 'absent',
    },
    serviceConfig: { serviceName: 'CountersService', autogeneratedStringId: false },
  },

  // ---- string + manual (catalog) ----
  // (with-catalog compile details are already in compile-backend.spec.ts + entity-graphql.spec.ts)

  // ---- string + cuid (auto) ----
  {
    fixture: 'with-auto-string-id',
    label: 'string id (cuid, auto)',
    prisma: {
      model: 'Ticket',
      idType: 'String',
      hasCuid: true,
      extraFields: [{ pattern: /subject\s+String/ }],
    },
    typeDefs: {
      entity: 'Ticket',
      service: 'tickets',
      gqlIdType: 'ID!',
      requiredFields: ['subject: String!'],
      createMutationIdBehaviour: 'absent',
    },
    serviceConfig: { serviceName: 'TicketsService', autogeneratedStringId: true },
  },

  // ---- document entity ----
  {
    fixture: 'with-document',
    label: 'document entity (Order)',
    prisma: {
      model: 'Order',
      idType: 'String',
      extraFields: [
        { pattern: /date\s+DateTime/ },
        { pattern: /code\s+String/ },
        { pattern: /total\s+Float/ },
        { pattern: /notes\s+String\?/ },
      ],
    },
    typeDefs: {
      entity: 'Order',
      service: 'orders',
      gqlIdType: 'ID!',
      requiredFields: ['date: DateTime!', 'code: String!', 'total: Float!'],
      optionalFields: ['notes: String'],
      createMutationIdBehaviour: 'required',
      createMutationIdPattern: /date:/,
      filters: ['date_lte: DateTime', 'date_gte: DateTime', 'total_lte: Float', 'total_gte: Float'],
    },
    entityTs: { names: ['Order'] },
  },

  // ---- relations ----
  {
    fixture: 'with-relations',
    label: 'linked entities (Category + Article)',
    prisma: [
      { model: 'Category', idType: 'String' },
      {
        model: 'Article',
        idType: 'String',
        hasRelation: { field: 'categoryId', type: 'String', optional: true },
      },
    ],
    typeDefs: [
      {
        entity: 'Category',
        service: 'categories',
        gqlIdType: 'ID!',
        requiredFields: ['name: String!'],
        createMutationIdBehaviour: 'required',
        createMutationIdPattern: /id:/,
      },
      {
        entity: 'Article',
        service: 'articles',
        gqlIdType: 'ID!',
        requiredFields: ['title: String!'],
        optionalFields: ['categoryId: String'],
        createMutationIdBehaviour: 'required',
        createMutationIdPattern: /id:/,
        filters: ['categoryId: String', 'categoryId_in: [String]', 'categoryId_not_in: [String]'],
      },
    ],
    entityTs: { names: ['Category', 'Article'] },
  },

  // ---- infoRegistry (non-periodic, non-registrar-depended) ----
  {
    fixture: 'with-info-registry',
    label: 'infoRegistry entity (Price)',
    prisma: {
      model: 'Price',
      idType: 'String',
      extraFields: [
        { pattern: /region\s+String/ },
        { pattern: /amount\s+Float/ },
      ],
    },
    typeDefs: {
      entity: 'Price',
      service: 'prices',
      gqlIdType: 'ID!',
      requiredFields: ['region: String!', 'amount: Float!'],
      createMutationIdBehaviour: 'required',
      createMutationIdPattern: /id:/,
    },
    entityTs: { names: ['Price'] },
  },

  // ---- sumRegistry (non-registrar-depended) ----
  {
    fixture: 'with-sum-registry',
    label: 'sumRegistry entity (Total)',
    prisma: {
      model: 'Total',
      idType: 'String',
      extraFields: [
        { pattern: /region\s+String/ },
        { pattern: /amount\s+Float/ },
      ],
    },
    typeDefs: {
      entity: 'Total',
      service: 'totals',
      gqlIdType: 'ID!',
      requiredFields: ['region: String!', 'amount: Float!'],
      createMutationIdBehaviour: 'required',
      createMutationIdPattern: /id:/,
    },
    entityTs: { names: ['Total'] },
  },
]

// ---------------------------------------------------------------------------
// Parameterized test runner — helper functions extracted to reduce complexity
// ---------------------------------------------------------------------------

function registerPrismaTests(pc: PrismaCheck, getBackDir: () => string): void {
  it(`Prisma: ${pc.model} has ${pc.idType} id${pc.hasAutoincrement ? ' (autoincrement)' : ''}${pc.hasCuid ? ' (cuid)' : ''}`, () => {
    const schema = readSchema(getBackDir())
    expect(schema).toContain(`model ${pc.model} {`)
    expect(schema).toMatch(new RegExp(`id\\s+${pc.idType}`))
    expect(schema).toContain('@id')

    if (pc.hasAutoincrement) {
      expect(schema).toContain('@default(autoincrement())')
    }
    if (pc.hasAutoincrement === false) {
      expect(schema).not.toContain('@default(autoincrement())')
    }
    if (pc.hasCuid) {
      expect(schema).toContain('@default(cuid())')
    }
  })

  if (pc.extraFields?.length) {
    it(`Prisma: ${pc.model} field types are correct`, () => {
      const schema = readSchema(getBackDir())
      for (const f of pc.extraFields ?? []) {
        expect(schema).toMatch(f.pattern)
      }
    })
  }

  if (pc.hasRelation) {
    it(`Prisma: ${pc.model} has ${pc.hasRelation.field} with @relation`, () => {
      const schema = readSchema(getBackDir())
      const typePattern = pc.hasRelation?.optional
        ? new RegExp(`${pc.hasRelation.field}\\s+${pc.hasRelation.type}\\?`)
        : new RegExp(`${pc.hasRelation?.field}\\s+${pc.hasRelation?.type}`)
      expect(schema).toMatch(typePattern)
      expect(schema).toContain('@relation')
    })
  }
}

function registerTypeDefsTests(td: TypeDefsCheck, getBackDir: () => string): void {
  it(`GraphQL: ${td.entity} type with id: ${td.gqlIdType}`, () => {
    const typeDefs = readTypeDefs(getBackDir(), td.service)
    expect(typeDefs).toContain(`type ${td.entity} {`)
    expect(typeDefs).toContain(`id: ${td.gqlIdType}`)

    for (const f of td.requiredFields ?? []) {
      expect(typeDefs).toContain(f)
    }
    for (const f of td.optionalFields ?? []) {
      expect(typeDefs).toContain(f)
    }
  })

  it(`GraphQL: ${td.entity} create mutation — id ${td.createMutationIdBehaviour}`, () => {
    const typeDefs = readTypeDefs(getBackDir(), td.service)
    const createMatch = typeDefs.match(new RegExp(`create${td.entity}\\(([^)]+)\\)`, 's'))
    expect(createMatch).toBeTruthy()
    const createArgs = createMatch?.[1] ?? ''

    if (td.createMutationIdBehaviour === 'required' && td.createMutationIdPattern) {
      expect(createArgs).toMatch(td.createMutationIdPattern)
    }
    if (td.createMutationIdBehaviour === 'absent') {
      const idRequiredPattern = new RegExp(`\\bid\\s*:\\s*${td.gqlIdType.replace('!', '\\!')}`)
      expect(createArgs).not.toMatch(idRequiredPattern)
    }
  })

  if (td.filters?.length) {
    it(`GraphQL: ${td.entity} filter has expected fields`, () => {
      const typeDefs = readTypeDefs(getBackDir(), td.service)
      expect(typeDefs).toContain(`input ${td.entity}Filter {`)
      for (const f of td.filters ?? []) {
        expect(typeDefs).toContain(f)
      }
    })
  }
}

for (const spec of fixtures) {
  describe(`e2e compile: ${spec.label} (${spec.fixture})`, () => {
    let prepared: PreparedBackend

    beforeAll(async () => {
      prepared = await prepareBackend(spec.fixture)
    }, 180000)

    afterAll(() => {
      teardownBackend({ prepared })
    })

    const getBackDir = () => prepared.backDir

    // ---------- universal checks ----------

    it('tsc --noEmit succeeds', () => {
      runOrFail('tsc', 'npx tsc --noEmit', {
        cwd: prepared.backDir,
        timeout: 30000,
      })
    })

    it('prisma validate succeeds', () => {
      runOrFail('prisma validate', 'npx prisma validate', {
        cwd: prepared.backDir,
        timeout: 15000,
        env: { ...process.env, DATABASE_MAIN_WRITE_URI: 'postgresql://localhost:5432/test' },
      })
    })

    it('generated Dockerfile is valid', () => {
      const dockerfile = fs.readFileSync(path.join(prepared.backDir, 'Dockerfile'), 'utf-8')
      expect(dockerfile).toContain('FROM')
      expect(dockerfile).toContain('COPY')
      expect(dockerfile).toContain('EXPOSE')
    })

    it('generated Helm chart has required fields', () => {
      const chart = fs.readFileSync(path.join(prepared.backDir, 'chart', 'Chart.yaml'), 'utf-8')
      expect(chart).toContain('apiVersion:')
      expect(chart).toContain('name:')
      expect(chart).toContain('version:')
    })

    it('Prisma schema has datasource and generator', () => {
      const schema = readSchema(getBackDir())
      expect(schema).toContain('datasource db')
      expect(schema).toContain('generator client')
      expect(schema).toContain('provider = "postgresql"')
    })

    // ---------- Prisma schema checks ----------

    const prismaChecks = Array.isArray(spec.prisma) ? spec.prisma : [spec.prisma]
    for (const pc of prismaChecks) {
      registerPrismaTests(pc, getBackDir)
    }

    // ---------- GraphQL typeDefs checks ----------

    const typeDefsChecks = Array.isArray(spec.typeDefs) ? spec.typeDefs : [spec.typeDefs]
    for (const td of typeDefsChecks) {
      registerTypeDefsTests(td, getBackDir)
    }

    // ---------- serviceConfig checks ----------

    if (spec.serviceConfig) {
      const sc = spec.serviceConfig
      it(`serviceConfig: autogeneratedStringId = ${sc.autogeneratedStringId}`, () => {
        const config = fs.readFileSync(
          path.join(prepared.backDir, `src/adm/services/${sc.serviceName}/config.ts`),
          'utf-8',
        )
        expect(config).toContain('autogeneratedStringId')
        const expectedPattern = sc.autogeneratedStringId
          ? /autogeneratedStringId.*true/
          : /autogeneratedStringId.*false/
        expect(config).toMatch(expectedPattern)
      })
    }

    // ---------- Entity.ts checks ----------

    if (spec.entityTs) {
      it(`Entity.ts exports ${spec.entityTs.names.join(', ')}`, () => {
        const entityTs = fs.readFileSync(
          path.join(prepared.backDir, 'src/types/Entity.ts'),
          'utf-8',
        )
        for (const name of spec.entityTs?.names ?? []) {
          expect(entityTs).toContain(name)
        }
      })
    }
  })
}
